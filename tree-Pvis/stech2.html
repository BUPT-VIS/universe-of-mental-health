<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.6.1/p5.js"></script>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <title>tree</title>
  </head>
  <body>
    <script>
      //载入数据
      // d3.csv("survey.csv", function(data) {
      //   lineData = data;
      //   console.log(lineData);
      // });
      //定义树的最大层级
      var maxLevel = 3; // The amount of nested branches it will subdivide to. More is slower!
      var branchForce = 0.5;
      // The branch's resistance against the mouse. A lower value will make it feel sluggish, while a bigger value will make it spring-like.
      var rootBranch = null;
      var debug = false;

      function setup() {
        createCanvas(windowWidth, windowHeight);
        colorMode(HSB, 255);
        generateNewTree();
      }

      function draw() {
        background(50);

        push();
        translate(width / 2, height - height / 8);
        treeIterator(rootBranch, 0, 0, 0);
        pop();

        //文字样式
        fill(255);
        noStroke();

        text(
          "".concat(
            "Click to change to a new tree.\n",
            "Middle-click to toggle debug mode.\n",
            "Move the mouse over the tree to interact with it.\n",
            "\n",
            "Debug mode: ",
            debug
          ),
          50,
          50
        );
      }

      function mousePressed() {
        if (mouseButton == CENTER) {
          debug = !debug;
        } else {
          generateNewTree();
        }
      }
    </script>

    <script>
      // A branch's position is always relative to its parent.
      function Branch(length, angle, level) {
        this.vel = 0;
        this.acc = 0; //加速度
        this.level = level;
        this.angle = angle;
        this.restAngle = angle; //回弹角度
        this.length = length;
        this.children = [];
        this.leaves = [];
        this.newBranchCount;

        // If the branch is high enough then begin spawning leaves and berries.
        if (this.level > maxLevel - 3) {
          for (let i = 0; i < int(random(6)); i++) {
            if (i % 6 == 0) {
              this.leaves.push(new Berry());
            } else {
              //this.leaves.push(new Leaf());
            }
          }
        }

        // Adds a new branch as a child.
        this.newBranch = function(angle, mult) {
          let newBranch = new Branch(this.length * mult, angle, this.level + 1);
          console.log(this.level);
          this.children.push(newBranch);
          return newBranch;
        };

        if (this.level == 0) {
          newBranchCount = 2;
        } else if (this.level == 1) {
          newBranchCount = 3;
        } else if (this.level == 2) {
          newBranchCount = 5;
        }else if (this.level == 3) {
          newBranchCount = 1;
        }

        // Adds a new velocity to its acceleration.
        //树枝加速度

        this.applyForce = function(force) {
          this.acc += force;
        };

        // Simulates its new angle.
        this.move = function() {
          // Add some weak wind so there's subtle motion when it's idle.
          let windMult =
            map(this.level, 0, maxLevel, 0.1, 1) * random(0.75, 1.25);
          let wind = noise(frameCount /*帧率*/ * 0.002) * 0.5 * windMult; //设置噪点
          this.applyForce(wind);

          // Always have the angle chasing back to its rest pose.
          // This is what causes the branches to bounce.
          //设置树枝回弹
          let angleThresh = 10;
          //设置弹簧向量
          let spring = new p5.Vector(this.restAngle, 0);
          let distance = dist(this.angle, 0, this.restAngle, 0);
          let force = map(
            min(distance, angleThresh),
            0,
            angleThresh,
            0,
            branchForce
          );
          spring.sub(new p5.Vector(this.angle, 0));
          spring.normalize();
          spring.mult(force);
          this.applyForce(spring.x);

          // Slow down velocity with air drag.
          this.vel *= 0.95;

          // Add acceleration to velocity, and then to the angle.
          this.vel += this.acc;
          this.angle += this.vel;
          this.angle = constrain(
            this.angle,
            this.restAngle - 45,
            this.restAngle + 45 //把回弹限制在±45°之间
          ); // Limit how far its angle can bend, otherwise it could spin!
          this.acc = 0;
        };
      }
    </script>

    <script>
      // Takes a branch and spawns new children branches that will come from it.
      //获取分支
      // This is a recursive function that makes up the tree's structure.
      function subDivide(branch) {
        let newBranches = [];
        // let newBranchCount=3;
        let minLength = 0.7;
        let maxLength = 0.85;

        // The angles will change depending on how many new branches will be created.
        //树枝分叉角度取决于树杈数量
        // This will allow the tree to have more natural looking angles than being random.
        if (newBranchCount == 2) {
          newBranches.push(
            branch.newBranch(random(-45.0, -10.0), random(minLength, maxLength))
          );
          newBranches.push(
            branch.newBranch(random(10.0, 45.0), random(minLength, maxLength))
          );
        } else if (newBranchCount == 3) {
          newBranches.push(
            branch.newBranch(random(-45.0, -15.0), random(minLength, maxLength))
          );
          newBranches.push(
            branch.newBranch(random(-10.0, 10.0), random(minLength, maxLength))
          );
          newBranches.push(
            branch.newBranch(random(15.0, 45.0), random(minLength, maxLength))
          );
        } else if (newBranchCount == 5) {
          newBranches.push(
            branch.newBranch(random(-45.0, -27.0), random(minLength, maxLength))
          );
          newBranches.push(
            branch.newBranch(random(-27.0, -9.0), random(minLength, maxLength))
          );
          newBranches.push(
            branch.newBranch(random(-9.0, 9.0), random(minLength, maxLength))
          );
          newBranches.push(
            branch.newBranch(random(9.0, 27.0), random(minLength, maxLength))
          );
          newBranches.push(
            branch.newBranch(random(27.0, 45.0), random(minLength, maxLength))
          );
        } else if (newBranchCount == 1) {
          newBranches.push(
            branch.newBranch(random(-45.0, 45.0), random(minLength, maxLength))
          );
        }

        // If the new branches haven't reach the max level yet then spawn new branches from them.
        //在最大层级内生成新分支
        for (let i = 0; i < newBranches.length; i++) {
          console.log(newBranches[i]);
          if (newBranches[i].level < maxLevel) {
            subDivide(newBranches[i]);
          }
        }
      }
    </script>

    <script>
      // Creates a new tree. The first branch is always vertical in the scene's center.
      function generateNewTree() {
        rootBranch = new Branch(random(80.0, 150.0), -90, 0);
        subDivide(rootBranch);
      }
    </script>

    <script>
      // A recursive function to display the tree.
      // It uses `push` and `pop` so that we don't have to deal with actual positions.
      // Instead we only care about a branch's length and angle so that we can position them relatively.
      function treeIterator(branch, worldX, worldY, worldA) {
        // Even though `push` and `pop` will help *display* the tree, we still need a means to interact with it.
        // So to interact with the mouse, we must keep track of the current branch's world position/rotation.
        worldA += branch.angle;

        let vec = new p5.Vector(branch.length, 0);
        vec.rotate(radians(worldA));

        worldX += vec.x;
        worldY += vec.y;

        push();
        stroke(15, 100, 150 * map(branch.level, 0, maxLevel, 1, 1.5));
        strokeWeight(maxLevel - branch.level + 1);

        // Push the branch if it's within distance of the mouse.
        let d = dist(
          mouseX,
          mouseY,
          worldX + width / 2,
          worldY + height - height / 4
        );
        let distThresh = 250;
        if (d < distThresh) {
          let force = map(d, 0, distThresh, 1, 0); // Closer branches will be pushed more.

          // Reverse angle depending on mouse position.
          if (mouseX > worldX + width / 2) {
            force *= -1;
          }

          // Lower branches have greater resistance.
          force *= map(branch.level, 0, maxLevel, 0.2, 1);
          branch.applyForce(force);

          // While we're here, we can visualize if this branch is being pushed.
          if (debug) {
            stroke(0, 255, 255);
          }
        }

        // Simulate branch.
        branch.move();

        rotate(radians(branch.angle));

        // Draw branch.
        line(0, 0, branch.length, 0);

        if (debug) {
          // Draw debug points.
          if (d < 200) {
            stroke(80, 255, 255);
            strokeWeight(5);
            point(0, 0);
          }
        } else {
          // Draw leaves and berries.
          if (branch.leaves.length > 0) {
            for (let i = 0; i < branch.leaves.length; i++) {
              stroke(
                branch.leaves[i].hue,
                branch.leaves[i].sat,
                branch.leaves[i].val,
                branch.leaves[i].opacity
              );
              strokeWeight(branch.leaves[i].size);
              point(
                branch.length + branch.leaves[i].offsetX,
                branch.leaves[i].offsetY
              );
            }
          }
        }

        translate(branch.length, 0);

        // Continue iterating to children branches, and pass world values.
        for (let i = 0; i < branch.children.length; i++) {
          treeIterator(branch.children[i], worldX, worldY, worldA);
        }
        pop();
      }
    </script>

    <script>
      // A leaf's position is always relative to its parent branch.
      function Leaf() {
        this.hue = random(70, 90);
        this.sat = random(130, 150);
        this.val = random(150, 220);
        this.opacity = random(20, 70);
        this.size = random(10, 60);
        this.offsetX = random(-10, 10);
        this.offsetY = random(-10, 10);
      }
    </script>

    <script>
      // A berry's position is always relative to its parent branch.
      function Berry() {
        this.hue = random(0, 25);
        this.sat = random(200, 255);
        this.val = random(200, 230);
        this.opacity = random(150, 200);
        this.size = random(3, 8);
        this.offsetX = random(-5, 5);
        this.offsetY = random(-5, 5);
      }
    </script>
  </body>
</html>
